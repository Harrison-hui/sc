
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="Harrison">
      
      
        <link rel="canonical" href="https://biomed-notebook.cn/numpy/2.%2B%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%2Bb1e5aded-809e-4f5e-8eeb-bf5278c70410/">
      
      
        <link rel="prev" href="../1.%2B%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%9B%E5%BB%BA%2B101c0975-b67c-4216-8719-591a35b324bb/">
      
      
        <link rel="next" href="../../%E5%8D%95%E7%BB%86%E8%83%9E/01.%2BAnData%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Bf42be259-849d-43ee-bd34-e610de1f0ede/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.3">
    
    
      
        <title>2.+数组的操作 - 数据分析笔记</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.d7758b05.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../.." title="数据分析笔记" class="md-header__button md-logo" aria-label="数据分析笔记" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            数据分析笔记
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              2.+数组的操作
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="数据分析笔记" class="md-nav__button md-logo" aria-label="数据分析笔记" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    数据分析笔记
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    首页
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    numpy
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            numpy
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../1.%2B%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%88%9B%E5%BB%BA%2B101c0975-b67c-4216-8719-591a35b324bb/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1.+数组的概念及创建
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    2.+数组的操作
    
  </span>
  

      </a>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    pandas
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    scipy
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    matplotlib
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    seaborn
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
        
          
          <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    单细胞
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_7">
            <span class="md-nav__icon md-icon"></span>
            单细胞
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../%E5%8D%95%E7%BB%86%E8%83%9E/01.%2BAnData%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Bf42be259-849d-43ee-bd34-e610de1f0ede/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    01.AnData数据结构
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    机器学习
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="_1">常数</h1>
<ol>
<li>
<p>正无穷大: Inf、Infinity、PINF、infty、inf</p>
</li>
<li>
<p>负无穷大: NINF</p>
</li>
<li>
<p>非数字: NAN、NaN、nan</p>
</li>
<li>
<p>正零: PZERO</p>
</li>
<li>
<p>负零: NZERO</p>
</li>
<li>
<p>自然常数e: e</p>
</li>
<li>
<p>欧拉常数γ: euler_gamma</p>
</li>
<li>
<p>π: pi</p>
</li>
<li>
<p>None: newaxis，主要用于索引数组</p>
</li>
</ol>
<pre><code class="language-Python">print(np.Inf, np.Infinity, np.PINF, np.infty, np.inf)
&quot;&quot;&quot;
inf inf inf inf inf
&quot;&quot;&quot;

print(np.NINF)
&quot;&quot;&quot;
-inf
&quot;&quot;&quot;

print(np.NAN, np.NaN, np.nan)
&quot;&quot;&quot;
nan nan nan
&quot;&quot;&quot;

print(np.PZERO)
&quot;&quot;&quot;
0.0
&quot;&quot;&quot;

print(np.NZERO)
&quot;&quot;&quot;
-0.0
&quot;&quot;&quot;

print(np.e)
&quot;&quot;&quot;
2.718281828459045
&quot;&quot;&quot;

print(np.euler_gamma)
&quot;&quot;&quot;
0.5772156649015329
&quot;&quot;&quot;

print(np.pi)
&quot;&quot;&quot;
3.141592653589793
&quot;&quot;&quot;

print(np.newaxis)
&quot;&quot;&quot;
None
&quot;&quot;&quot;

n0 = np.array([1, 2, 3, 4])
print(n0[np.newaxis, :])
&quot;&quot;&quot;
[[1 2 3 4]]
&quot;&quot;&quot;

print(n0[np.newaxis])
&quot;&quot;&quot;
[[1 2 3 4]]
&quot;&quot;&quot;

print(n0[None])
&quot;&quot;&quot;
[[1 2 3 4]]
&quot;&quot;&quot;

print(n0[:, np.newaxis])
&quot;&quot;&quot;
[[1]
 [2]
 [3]
 [4]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_2">类型转换</h1>
<p>在上一节中关于dtype有详细介绍。其中的类型可以作为函数用于数据类型转换</p>
<pre><code class="language-Python">n = 3.14
n_int8 = np.int8(n)
print(n_int8)
&quot;&quot;&quot;
3
&quot;&quot;&quot;

n_bool = np.bool_(n)
print(n_bool)
&quot;&quot;&quot;
True
&quot;&quot;&quot;
</code></pre>
<h1 id="_3">数组属性</h1>
<ol>
<li>
<p><strong>shape</strong>: 形状</p>
</li>
<li>
<p><strong>dtype</strong>: 数据类型</p>
</li>
<li>
<p><strong>ndim</strong>: 维度</p>
</li>
<li>
<p><strong>base</strong>: 基类数组</p>
</li>
<li>
<p><strong>flat</strong>: 一维数组迭代器</p>
</li>
<li>
<p><strong>imag</strong>:虚部</p>
</li>
<li>
<p><strong>real</strong>: 实部</p>
</li>
<li>
<p><strong>size</strong>: 总元素数=维数乘积</p>
</li>
<li>
<p><strong>itemsize</strong>: 每个元素占的字节数</p>
</li>
<li>
<p><strong>nbytes</strong>: 总元素字节数=size * itemsize</p>
</li>
<li>
<p><strong>strides</strong>:每个维度上进入到下一个数需要跨越的字节数</p>
</li>
<li>
<p><strong>flags</strong>: 内存布局信息</p>
</li>
<li>
<p>ctypes</p>
</li>
<li>
<p>data</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.arange(12)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;
n1 = n0.reshape(3, 4)
print(n1)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

# shape属性: 形状
print(n1.shape)
&quot;&quot;&quot;
(3, 4)
&quot;&quot;&quot;

# dtype属性: 数据类型
print(n1.dtype)
&quot;&quot;&quot;
int32
&quot;&quot;&quot;

# ndim属性: 维度
print(n1.ndim)
&quot;&quot;&quot;
2
&quot;&quot;&quot;

# base属性: 基类数组
print(n1.base, n1.base is n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11] True
&quot;&quot;&quot;

# flat属性: 一维数组迭代器
print(n1.flat, np.array(n1.flat))
&quot;&quot;&quot;
&lt;numpy.flatiter object at 0x000001F088E46760&gt; [ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

# imag属性:虚部
print(n1.imag)
&quot;&quot;&quot;
[[0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]]
&quot;&quot;&quot;

# real属性: 实部
print(n1.real)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

# size属性: 总元素数=维数乘积
print(n1.size)
&quot;&quot;&quot;
12
&quot;&quot;&quot;

# itemsize属性: 每个元素占的字节数
print(n1.itemsize)
&quot;&quot;&quot;
4
&quot;&quot;&quot;

# nbytes属性: 总元素字节数=size * itemsize
print(n1.nbytes)
&quot;&quot;&quot;
48
&quot;&quot;&quot;

# strides属性:每个维度上进入到下一个数需要跨越的字节数
print(n1.strides)
&quot;&quot;&quot;
(16, 4)
&quot;&quot;&quot;

# flags属性: 内存布局信息
print(n1.flags)
&quot;&quot;&quot;
  C_CONTIGUOUS : True
  F_CONTIGUOUS : False
  OWNDATA : False
  WRITEABLE : True
  ALIGNED : True
  WRITEBACKIFCOPY : False
&quot;&quot;&quot;

# ctypes属性
print(n1.ctypes)
&quot;&quot;&quot;
&lt;numpy.core._internal._ctypes object at 0x00000203AF48EF00&gt;
&quot;&quot;&quot;

# data属性
print(n1.data)
&quot;&quot;&quot;
&lt;memory at 0x00000203AF4C0520&gt;
&quot;&quot;&quot;
</code></pre>
<h1 id="_4">数组运算</h1>
<h2 id="add">加法运算（+、add函数）</h2>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 + n2)
&quot;&quot;&quot;
[ 6  8 10 12]
&quot;&quot;&quot;

print(n1 + n3)
&quot;&quot;&quot;
[[2 3 4 5]
 [6 7 8 9]]
&quot;&quot;&quot;

print(n1 + n4)
&quot;&quot;&quot;
[[ 2  4  6  8]
 [ 6  8 10 12]]
&quot;&quot;&quot;

print(n3 + n4)
&quot;&quot;&quot;
[[ 2  3  4  5]
 [10 11 12 13]]
&quot;&quot;&quot;

print(np.add(n3, n4))
&quot;&quot;&quot;
[[ 2  3  4  5]
 [10 11 12 13]]
&quot;&quot;&quot;
</code></pre>
<h2 id="-subtract">减法运算（-、subtract函数）</h2>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 - n2)
&quot;&quot;&quot;
[-4 -4 -4 -4]
&quot;&quot;&quot;

print(n1 - n3)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [-4 -3 -2 -1]]
&quot;&quot;&quot;

print(n1 - n4)
&quot;&quot;&quot;
[[ 0  0  0  0]
 [-4 -4 -4 -4]]
&quot;&quot;&quot;

print(n3 - n4)
&quot;&quot;&quot;
[[ 0 -1 -2 -3]
 [ 0 -1 -2 -3]]
&quot;&quot;&quot;

print(np.subtract(n3, n4))
&quot;&quot;&quot;
[[ 0 -1 -2 -3]
 [ 0 -1 -2 -3]]
&quot;&quot;&quot;
</code></pre>
<h2 id="multiply">乘法运算（*、multiply函数）</h2>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 * n2)
&quot;&quot;&quot;
[ 5 12 21 32]
&quot;&quot;&quot;

print(n1 * n3)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [ 5 10 15 20]]
&quot;&quot;&quot;

print(n1 * n4)
&quot;&quot;&quot;
[[ 1  4  9 16]
 [ 5 12 21 32]]
&quot;&quot;&quot;

print(n3 * n4)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [25 30 35 40]]
&quot;&quot;&quot;

print(np.multiply(n3, n4))
&quot;&quot;&quot;
[[ 1  2  3  4]
 [25 30 35 40]]
&quot;&quot;&quot;
</code></pre>
<h2 id="dividetrue_divide">除法运算（/、divide函数、true_divide函数）</h2>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 / n2)
&quot;&quot;&quot;
[0.2        0.33333333 0.42857143 0.5       ]
&quot;&quot;&quot;

print(n1 / n3)
&quot;&quot;&quot;
[[1.  2.  3.  4. ]
 [0.2 0.4 0.6 0.8]]
&quot;&quot;&quot;

print(n1 / n4)
&quot;&quot;&quot;
[[1.         1.         1.         1.        ]
 [0.2        0.33333333 0.42857143 0.5       ]]
&quot;&quot;&quot;

print(n3 / n4)
&quot;&quot;&quot;
[[1.         0.5        0.33333333 0.25      ]
 [1.         0.83333333 0.71428571 0.625     ]]
&quot;&quot;&quot;

print(np.divide(n3, n4))
&quot;&quot;&quot;
[[1.         0.5        0.33333333 0.25      ]
 [1.         0.83333333 0.71428571 0.625     ]]
&quot;&quot;&quot;

print(np.true_divide(n3, n4))
&quot;&quot;&quot;
[[1.         0.5        0.33333333 0.25      ]
 [1.         0.83333333 0.71428571 0.625     ]]
&quot;&quot;&quot;
</code></pre>
<h2 id="floor_divide">整除（地板除）运算（//、floor_divide函数）</h2>
<p><strong>满足a = a % b + b * (a // b)</strong></p>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 // n2)
&quot;&quot;&quot;
[0 0 0 0]
&quot;&quot;&quot;

print(n1 // n3)
&quot;&quot;&quot;
[[1 2 3 4]
 [0 0 0 0]]
&quot;&quot;&quot;

print(n1 // n4)
&quot;&quot;&quot;
[[1 1 1 1]
 [0 0 0 0]]
&quot;&quot;&quot;

print(n3 // n4)
&quot;&quot;&quot;
[[1 0 0 0]
 [1 0 0 0]]
&quot;&quot;&quot;

print(np.floor_divide(n3, n4))
&quot;&quot;&quot;
[[1 0 0 0]
 [1 0 0 0]]
&quot;&quot;&quot;
</code></pre>
<h2 id="remaindermodfmoddivmod">取余（模）运算（%、remainder函数、mod函数、fmod函数、divmod函数）</h2>
<ol>
<li>
<p>%、remainder函数、mod函数: 满足<strong>a = a % b + b * (a // b)</strong></p>
</li>
<li>
<p>fmod函数：结果<strong>符号与被除数相同</strong>。<strong>|结果| = |a| % |b|</strong></p>
</li>
<li>
<p>divmod函数: 同时返回商与余数</p>
</li>
</ol>
<pre><code class="language-Python">n1 = np.array([1, -2, 3, -4])
n2 = np.array([5, -6, -7, 8])
n3 = np.array([[-1], [5]])
n4 = np.array([[1, -2, 3, -4], [-5, -6, -7, 8]])

print(n1 % n2)
&quot;&quot;&quot;
[ 1 -2 -4  4]
&quot;&quot;&quot;

print(n1 % n3)
&quot;&quot;&quot;
[[0 0 0 0]
 [1 3 3 1]]
&quot;&quot;&quot;

print(n1 % n4)
&quot;&quot;&quot;
[[ 0  0  0  0]
 [-4 -2 -4  4]]
&quot;&quot;&quot;

print(n3 % n4)
&quot;&quot;&quot;
[[ 0 -1  2 -1]
 [ 0 -1 -2  5]]
&quot;&quot;&quot;

print(np.remainder(n3, n4))
&quot;&quot;&quot;
[[ 0 -1  2 -1]
 [ 0 -1 -2  5]]
&quot;&quot;&quot;

print(np.mod(n3, n4))
&quot;&quot;&quot;
[[ 0 -1  2 -1]
 [ 0 -1 -2  5]]
&quot;&quot;&quot;

print(np.fmod(n3, n4))
&quot;&quot;&quot;
[[ 0 -1 -1 -1]
 [ 0  5  5  5]]
&quot;&quot;&quot;

print(np.divmod(n3, n4))
&quot;&quot;&quot;
(array([[-1,  0, -1,  0],
       [-1, -1, -1,  0]]), 
 array([[ 0, -1,  2, -1],
       [ 0, -1, -2,  5]]))
&quot;&quot;&quot;
</code></pre>
<h2 id="matmuldot">点积运算（@、matmul函数、dot函数）</h2>
<p>第一个数组列数必须与第二个数组的行数相同，对应行列乘积相加的结果为运算结果对应行列的元素</p>
<p>即形状为(m, k)的数组与形状为(k, n)的数组的点积结果为一个形状为(m, n)的数组</p>
<p>matmul函数支持广播机制，不支持标量乘法运算</p>
<p>dot函数不支持广播机制，支持标量乘法运算</p>
<p><img alt="image.png" src="image.png" /></p>
<ol>
<li>
<p>第一个数组若为一维，则其将被提升为二维，并视为二维数组的一行，结果仍为一维数组</p>
</li>
<li>
<p>第二个数组若为一维，则其将被提升为二维，并视为二维数组的一列，结果仍为一维数组</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.array([1, 2, 3, 4])
print(n0)
&quot;&quot;&quot;
[1 2 3 4]
&quot;&quot;&quot;

n1 = np.array([5, 6, 7, 8])
print(n1)
&quot;&quot;&quot;
[5 6 7 8]
&quot;&quot;&quot;

n2 = np.arange(1, 17).reshape(4, 4)
print(n2)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]
 [13 14 15 16]]
&quot;&quot;&quot;

print(n0 @ n1)
&quot;&quot;&quot;
70
&quot;&quot;&quot;

print(n0 @ n2)
&quot;&quot;&quot;
[ 90 100 110 120]
&quot;&quot;&quot;

print(n2 @ n0)
&quot;&quot;&quot;
[ 30  70 110 150]
&quot;&quot;&quot;

print(n2 @ n2)
&quot;&quot;&quot;
[[ 90 100 110 120]
 [202 228 254 280]
 [314 356 398 440]
 [426 484 542 600]]
&quot;&quot;&quot;

print(np.matmul(n2, n2))
&quot;&quot;&quot;
[[ 90 100 110 120]
 [202 228 254 280]
 [314 356 398 440]
 [426 484 542 600]]
&quot;&quot;&quot;

print(np.dot(n2, n2))
&quot;&quot;&quot;
[[ 90 100 110 120]
 [202 228 254 280]
 [314 356 398 440]
 [426 484 542 600]]
&quot;&quot;&quot;

print(np.dot(n2, 3))
&quot;&quot;&quot;
[[ 3  6  9 12]
 [15 18 21 24]
 [27 30 33 36]
 [39 42 45 48]]
&quot;&quot;&quot;
</code></pre>
<h2 id="powerfloat_power">乘方运算（**、power函数、float_power函数）</h2>
<p>负数的非整数幂将返回nan</p>
<p>float_power函数与power函数的不同之处在于，整数、float16 和 float32 被提升为最小精度为 float64 的浮点数，因此结果总是不准确的</p>
<p>power函数不支持整数的负数幂</p>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 ** n2)
&quot;&quot;&quot;
[    1    64  2187 65536]
&quot;&quot;&quot;

print(n1 ** n3)
&quot;&quot;&quot;
[[   1    2    3    4]
 [   1   32  243 1024]]
&quot;&quot;&quot;

print(n1 ** n4)
&quot;&quot;&quot;
[[    1     4    27   256]
 [    1    64  2187 65536]]
&quot;&quot;&quot;

print(n3 ** n4)
&quot;&quot;&quot;
[[     1      1      1      1]
 [  3125  15625  78125 390625]]
&quot;&quot;&quot;

print(np.power(n3, n4))
&quot;&quot;&quot;
[[     1      1      1      1]
 [  3125  15625  78125 390625]]
&quot;&quot;&quot;

print(np.power(-1, 1.5))
&quot;&quot;&quot;
imeWarning: invalid value encountered in power
  print(np.power(-1, 1.5))
nan
&quot;&quot;&quot;

print(np.float_power(1, -1))
&quot;&quot;&quot;
1.0
&quot;&quot;&quot;

print(type(np.power(2, 2)), type(np.float_power(2, 2)))
&quot;&quot;&quot;
&lt;class 'numpy.int32'&gt; &lt;class 'numpy.float64'&gt;
&quot;&quot;&quot;
</code></pre>
<h2 id="_5">比较运算</h2>
<ol>
<li>
<blockquote>
<p>: greater函数</p>
</blockquote>
</li>
<li>
<blockquote>
<p>=: greater_equal函数</p>
</blockquote>
</li>
<li>
<p>&lt;: less函数</p>
</li>
<li>
<p>&lt;=: less_equal函数</p>
</li>
<li>
<p>!=: not_equal函数</p>
</li>
<li>
<p>==: equal函数</p>
</li>
<li>
<p>最大值: maximum函数（二者之一为nan则返回nan）、fmax（二者之一为nan则返回非nan），二者均为nan则返回第一个元素（适用于复数，复数至少实部或虚部之一为nan即为nan）</p>
</li>
<li>
<p>最小值: minimum函数（二者之一为nan则返回nan）、fmin（二者之一为nan则返回非nan），二者均为nan则返回第一个元素（适用于复数，复数至少实部或虚部之一为nan即为nan）</p>
</li>
</ol>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 &gt;= n2)
&quot;&quot;&quot;
[False False False False]
&quot;&quot;&quot;

print(n1 &gt;= n3)
&quot;&quot;&quot;
[[ True  True  True  True]
 [False False False False]]
&quot;&quot;&quot;

print(n1 &gt;= n4)
&quot;&quot;&quot;
[[ True  True  True  True]
 [False False False False]]
&quot;&quot;&quot;

print(n3 &gt;= n4)
&quot;&quot;&quot;
[[ True False False False]
 [ True False False False]]
&quot;&quot;&quot;

print(np.greater_equal(n3, n4))
&quot;&quot;&quot;
[[ True False False False]
 [ True False False False]]
&quot;&quot;&quot;

print(np.maximum(n3, n4))
&quot;&quot;&quot;
[[1 2 3 4]
 [5 6 7 8]]
&quot;&quot;&quot;

print(np.minimum(n3, n4))
&quot;&quot;&quot;
[[1 1 1 1]
 [5 5 5 5]]
&quot;&quot;&quot;

print(np.fmax(n3, n4))
&quot;&quot;&quot;
[[1 2 3 4]
 [5 6 7 8]]
&quot;&quot;&quot;

print(np.fmin(n3, n4))
&quot;&quot;&quot;
[[1 1 1 1]
 [5 5 5 5]]
&quot;&quot;&quot;
</code></pre>
<h2 id="_6">逻辑运算</h2>
<ol>
<li>
<p>与运算: logical_and函数</p>
</li>
<li>
<p>或运算: logical_or函数</p>
</li>
<li>
<p>非运算: logical_not函数</p>
</li>
<li>
<p>异或运算: logical_xor函数</p>
</li>
</ol>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(np.logical_and(n1, n2))
&quot;&quot;&quot;
[ True  True  True  True]
&quot;&quot;&quot;

print(np.logical_and(n1, n3))
&quot;&quot;&quot;
[[ True  True  True  True]
 [ True  True  True  True]]
&quot;&quot;&quot;

print(np.logical_and(n1, n4))
&quot;&quot;&quot;
[[ True  True  True  True]
 [ True  True  True  True]]
&quot;&quot;&quot;

print(np.logical_and(n3, n4))
&quot;&quot;&quot;
[[ True  True  True  True]
 [ True  True  True  True]]
&quot;&quot;&quot;
</code></pre>
<h2 id="_7">按位运算</h2>
<ol>
<li>
<p>与运算: &amp;、bitwise_and函数</p>
</li>
<li>
<p>或运算: |、bitwise_or函数</p>
</li>
<li>
<p>异或运算: ^、bitwise_xor函数</p>
</li>
<li>
<p>左移位运算: &lt;&lt;、left_shift函数</p>
</li>
<li>
<p>右移位运算: &gt;&gt;、right_shift函数</p>
</li>
<li>
<p>取反运算: ~、invert函数</p>
</li>
</ol>
<pre><code class="language-Python">n1 = np.array([1, 2, 3, 4])
n2 = np.array([5, 6, 7, 8])
n3 = np.array([[1], [5]])
n4 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])

print(n1 &amp; n2)
&quot;&quot;&quot;
[1 2 3 0]
&quot;&quot;&quot;

print(n1 &amp; n3)
&quot;&quot;&quot;
[[1 0 1 0]
 [1 0 1 4]]
&quot;&quot;&quot;

print(n1 &amp; n4)
&quot;&quot;&quot;
[[1 2 3 4]
 [1 2 3 0]]
&quot;&quot;&quot;

print(n3 &amp; n4)
&quot;&quot;&quot;
[[1 0 1 0]
 [5 4 5 0]]
&quot;&quot;&quot;

print(np.bitwise_and(n3, n4))
&quot;&quot;&quot;
[[1 0 1 0]
 [5 4 5 0]]
&quot;&quot;&quot;
</code></pre>
<h2 id="_8">标量运算</h2>
<p>即与一个单独的数进行运算，数组中每个数据都与该数进行运算</p>
<pre><code class="language-Python">n0 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(n0 * 2)
&quot;&quot;&quot;
[[ 2  4  6  8]
 [10 12 14 16]]
&quot;&quot;&quot;

n1 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(n1 &gt; 2)
&quot;&quot;&quot;
[[False False  True  True]
 [ True  True  True  True]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_9">数组索引与切片</h1>
<p>类似列表、元组等，对于二维及以上数组有其独特的索引和切片方式，逐层索引
结构化数组的索引类似于字典</p>
<ol>
<li>
<p>ndarray[n][m]...</p>
</li>
<li>
<p>ndarray[n, m, ...]</p>
</li>
</ol>
<pre><code class="language-Python"># 一维数组
n0 = np.arange(10)
print(n0)
&quot;&quot;&quot;
[0 1 2 3 4 5 6 7 8 9]
&quot;&quot;&quot;

print(n0[3])
&quot;&quot;&quot;
3
&quot;&quot;&quot;
print(n0[:4])
&quot;&quot;&quot;
[0 1 2 3]
&quot;&quot;&quot;

print(n0[2:])
&quot;&quot;&quot;
[2 3 4 5 6 7 8 9]
&quot;&quot;&quot;

print(n0[1:9:2])
&quot;&quot;&quot;
[1 3 5 7]
&quot;&quot;&quot;

print(n0[::-1])
&quot;&quot;&quot;
[9 8 7 6 5 4 3 2 1 0]
&quot;&quot;&quot;



# 二维数组
n1 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
print(n1)
&quot;&quot;&quot;
[[1 2 3 4]
 [5 6 7 8]]
&quot;&quot;&quot;

print(n1[1])
&quot;&quot;&quot;
[5 6 7 8]
&quot;&quot;&quot;

print(n1[0][2])
&quot;&quot;&quot;
3
&quot;&quot;&quot;

print(n1[0][1:])
&quot;&quot;&quot;
[2 3 4]
&quot;&quot;&quot;

print(n1[1, ])
&quot;&quot;&quot;
[5 6 7 8]
&quot;&quot;&quot;

print(n1[0, 2])
&quot;&quot;&quot;
3
&quot;&quot;&quot;

print(n1[0, 1:])
&quot;&quot;&quot;
[2 3 4]
&quot;&quot;&quot;

print(n1[0:, 2:])
&quot;&quot;&quot;
[[3 4]
 [7 8]]
&quot;&quot;&quot;



# 三维数组
n2 = np.array([[[1, 2, 3, 4], [5, 6, 7, 8]], [[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], [&quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;]]])
print(n2)
&quot;&quot;&quot;
[[['1' '2' '3' '4']
  ['5' '6' '7' '8']]

 [['a' 'b' 'c' 'd']
  ['e' 'f' 'g' 'h']]]
&quot;&quot;&quot;

print(n2[1])
&quot;&quot;&quot;
[['a' 'b' 'c' 'd']
 ['e' 'f' 'g' 'h']]
&quot;&quot;&quot;

print(n2[0][1])
&quot;&quot;&quot;
['5' '6' '7' '8']
&quot;&quot;&quot;

print(n2[0][1][3])
&quot;&quot;&quot;
8
&quot;&quot;&quot;

print(n2[0][0][2:])
&quot;&quot;&quot;
['3' '4']
&quot;&quot;&quot;

print(n2[1, ])
&quot;&quot;&quot;
[['a' 'b' 'c' 'd']
 ['e' 'f' 'g' 'h']]
&quot;&quot;&quot;

print(n2[0, 1])
&quot;&quot;&quot;
['5' '6' '7' '8']
&quot;&quot;&quot;

print(n2[0, 1, 3])
&quot;&quot;&quot;
8
&quot;&quot;&quot;

print(n2[0:, 1:, 2:])
&quot;&quot;&quot;
[[['7' '8']]

 [['g' 'h']]]
&quot;&quot;&quot;



# 结构化数组
dtype = np.dtype([('name', 'S10'), ('age', int), ('height', float)])
data = np.array([('Alice', 25, 5.6), ('Bob', 30, 6.0)], dtype=dtype)
print(data)
&quot;&quot;&quot;
[(b'Alice', 25, 5.6) (b'Bob', 30, 6. )]
&quot;&quot;&quot;

print(data[&quot;name&quot;])
&quot;&quot;&quot;
[b'Alice' b'Bob']
&quot;&quot;&quot;

print(data[&quot;age&quot;])
&quot;&quot;&quot;
[25 30]
&quot;&quot;&quot;

print(data[&quot;height&quot;])
&quot;&quot;&quot;
[5.6 6. ]
&quot;&quot;&quot;

print(data[&quot;height&quot;][1:])
&quot;&quot;&quot;
[6.]
&quot;&quot;&quot;

print(data[data[&quot;age&quot;] &gt; 26])
&quot;&quot;&quot;
[(b'Bob', 30, 6.)]
&quot;&quot;&quot;

dtype_nested = np.dtype([('info', [('name', 'S10'), ('age', int)]), ('height', float)])
data_nested = np.array([(('Alice', 25), 5.6), (('Bob', 30), 6.0)], dtype=dtype_nested)
print(data_nested)
&quot;&quot;&quot;
[((b'Alice', 25), 5.6) ((b'Bob', 30), 6. )]
&quot;&quot;&quot;

print(data_nested[&quot;info&quot;])
&quot;&quot;&quot;
[(b'Alice', 25) (b'Bob', 30)]
&quot;&quot;&quot;

print(data_nested[&quot;info&quot;][&quot;name&quot;])
&quot;&quot;&quot;
[b'Alice' b'Bob']
&quot;&quot;&quot;

print(data_nested[&quot;info&quot;][&quot;age&quot;])
&quot;&quot;&quot;
[25 30]
&quot;&quot;&quot;

print(data_nested[&quot;height&quot;])
&quot;&quot;&quot;
[5.6 6. ]
&quot;&quot;&quot;

print(data_nested[&quot;height&quot;][1:])
&quot;&quot;&quot;
[6.]
&quot;&quot;&quot;

print(data_nested[data_nested[&quot;info&quot;][&quot;age&quot;] &gt; 26])
&quot;&quot;&quot;
[((b'Bob', 30), 6.)]
&quot;&quot;&quot;
</code></pre>
<h1 id="reshape">数组重塑(reshape)</h1>
<p>即改变数组的形状，需注意<strong>改变形状后的数组size必须与原数组size相同</strong></p>
<h2 id="reshape_1">reshape方法</h2>
<p><code>ndarray.reshape(shape, order='C')</code></p>
<ol>
<li>
<p><strong>shape</strong>: 新形状，参数的元素可作为单独的参数传入</p>
</li>
<li>
<p><strong>order</strong>: 读取及写入的顺序。可选"C"（按行，默认）、"F"（按列）</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.arange(12)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n1 = n0.reshape(3, 4)
print(n1)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

n2 = n0.reshape([3, 4])
print(n2)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

n3 = n0.reshape(3, 4, order=&quot;F&quot;)
print(n3)
&quot;&quot;&quot;
[[ 0  3  6  9]
 [ 1  4  7 10]
 [ 2  5  8 11]]
&quot;&quot;&quot;

n4 = n3.reshape(2, 6, order=&quot;C&quot;)
print(n4)
&quot;&quot;&quot;
[[ 0  3  6  9  1  4]
 [ 7 10  2  5  8 11]]
&quot;&quot;&quot;

n5 = n3.reshape(2, 6, order=&quot;F&quot;)
print(n5)
&quot;&quot;&quot;
[[ 0  2  4  6  8 10]
 [ 1  3  5  7  9 11]]
&quot;&quot;&quot;
</code></pre>
<h2 id="reshape_2">reshape函数</h2>
<p><code>reshape(a, newshape, order='C')</code></p>
<ol>
<li>
<p><strong>a</strong>: 原数组</p>
</li>
<li>
<p><strong>newshape</strong>: 同上，但参数的元素不可作为单独的参数传入</p>
</li>
<li>
<p><strong>order</strong>: 同上</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.arange(12)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n6 = np.reshape(n0, [3, 4])
print(n6)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;
</code></pre>
<h1 id="transpose">数组转置(transpose)</h1>
<p>即行列转换</p>
<ol>
<li>
<p>一维数组转置后仍为原数组</p>
</li>
<li>
<p>二维数组转置后即两个轴互换</p>
</li>
<li>
<p>三维及以上数组转置可自定义轴的顺序</p>
</li>
</ol>
<h2 id="t">T属性</h2>
<p><code>ndarray.T</code></p>
<pre><code class="language-Python">n0 = np.arange(12)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n1 = np.arange(12).reshape(3, 4)
print(n1)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

n2 = n0.T
print(n2)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n3 = n1.T
print(n3)
&quot;&quot;&quot;
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
&quot;&quot;&quot;
</code></pre>
<h2 id="transpose_1">transpose方法</h2>
<p><code>ndarray.transpose(*axes)</code></p>
<ol>
<li><strong>axes</strong>: 即轴的顺序。轴i在第j个位置，表示将原数组的轴i变为转置数组的轴j。若未指定，则直接逆转轴的顺序</li>
</ol>
<pre><code class="language-Python">n0 = np.arange(12)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n1 = np.arange(12).reshape(3, 4)
print(n1)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

n4 = n0.transpose()
print(n4)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n5 = n1.transpose()
print(n5)
&quot;&quot;&quot;
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
&quot;&quot;&quot;

n6 = np.ones([3, 4, 5])    # 轴0大小为3，轴1大小为4， 轴2大小为5
print(n6, n6.shape)
&quot;&quot;&quot;
[[[1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]]

 [[1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]]

 [[1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]
  [1. 1. 1. 1. 1.]]] (3, 4, 5)
&quot;&quot;&quot;


n7 = n6.transpose(2, 0, 1)    # 轴2变轴0，现轴0大小为5；轴0变轴1，现轴1大小为3；轴1变轴2，现轴2大小为4
print(n7, n7.shape)
&quot;&quot;&quot;
[[[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]] (5, 3, 4)
&quot;&quot;&quot;

n8 = n6.transpose()    # 直接逆转轴的顺序，轴2变轴0，轴1变轴1，轴0变轴2
print(n8, n8.shape)
&quot;&quot;&quot;
[[[1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]]

 [[1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]
  [1. 1. 1.]]] (5, 4, 3)
&quot;&quot;&quot;
</code></pre>
<h2 id="transpose_2">transpose函数</h2>
<p><code>transpose(a, axes=None)</code></p>
<ol>
<li>
<p><strong>a</strong>: 原数组</p>
</li>
<li>
<p><strong>axes</strong>: 同上</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.arange(12)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n1 = np.arange(12).reshape(3, 4)
print(n1)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

n9 = np.transpose(n0)
print(n9)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n10 = np.transpose(n1)
print(n10)
&quot;&quot;&quot;
[[ 0  4  8]
 [ 1  5  9]
 [ 2  6 10]
 [ 3  7 11]]
&quot;&quot;&quot;

n11 = np.transpose(np.ones([3, 4, 5]), axes=[2, 0, 1])
print(n11, n11.shape)
&quot;&quot;&quot;
[[[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]

 [[1. 1. 1. 1.]
  [1. 1. 1. 1.]
  [1. 1. 1. 1.]]] (5, 3, 4)
&quot;&quot;&quot;
</code></pre>
<h1 id="_10">数组拼接</h1>
<h2 id="concatenate">concatenate函数</h2>
<p><code>concatenate(arrays, axis=0, out=None, dtype=None, casting="same_kind")</code></p>
<ol>
<li>
<p><strong>arrays</strong>: <strong>维度（ndim）相同</strong>的数组序列。这些数组除了指定axis方向，其它轴方向上大小必须相同</p>
</li>
<li>
<p><strong>axis</strong>: 沿该<strong>已有的轴</strong>进行拼接，不会产生新的轴。默认为0。若axis为None，则所有数组将被视为一维数组</p>
</li>
<li>
<p>out: 放置结果的目标数组。形状必须与拼接后数组的形状匹配。out数组的数据类型决定输出结果的数据类型</p>
</li>
<li>
<p>dtype: 数据类型。同上。不能与out参数同时提供</p>
</li>
<li>
<p>casting: 控制可能发生的数据转换类型。可选'no'、'equiv'、'safe'、'same_kind'（默认）、'unsafe'</p>
</li>
</ol>
<pre><code class="language-Python"># 二维数组
n0 = np.array([[1, 2, 3, 4]])
n1 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n2 = np.concatenate([n0, n1], axis=0)
print(n2)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [11 12 13 14]
 [15 16 17 18]]
&quot;&quot;&quot;

n3 = np.array([[1, 2, 3, 4, 5], [5, 6, 7, 8, 9]])
n4 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n5 = np.concatenate([n3, n4], axis=1)
print(n5)
&quot;&quot;&quot;
[[ 1  2  3  4  5 11 12 13 14]
 [ 5  6  7  8  9 15 16 17 18]]
&quot;&quot;&quot;

n6 = np.array([[1, 2, 3, 4, 5], [5, 6, 7, 8, 9]])
n7 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n8 = np.concatenate([n6, n7], axis=None)
print(n8)
&quot;&quot;&quot;
[ 1  2  3  4  5  5  6  7  8  9 11 12 13 14 15 16 17 18]
&quot;&quot;&quot;

n9 = np.array([[1, 2, 3, 4, 5], [5, 6, 7, 8, 9]])
n10 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n11 = np.concatenate([n9, n10], axis=1, out=np.ones([2, 9]))
print(n11)
&quot;&quot;&quot;
[[ 1.  2.  3.  4.  5. 11. 12. 13. 14.]
 [ 5.  6.  7.  8.  9. 15. 16. 17. 18.]]
&quot;&quot;&quot;



# 一维数组
n12 = np.array([1, 2, 3, 4])
n13 = np.array([11, 12, 13, 14])
n14 = np.concatenate([n12, n13], axis=0)    # 注意只有轴0，且为一维数组的已有轴0
print(n14)
&quot;&quot;&quot;
[ 1  2  3  4 11 12 13 14]
&quot;&quot;&quot;
n15 = np.array([[1, 2, 3, 4]])
n16 = np.array([[11, 12, 13, 14]])
n17 = np.concatenate([n15, n16], axis=0)    # 均为二维数组的一行而非一维数组，轴0为二维数组的轴0
print(n17)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [11 12 13 14]]
&quot;&quot;&quot;
</code></pre>
<h2 id="vstackrow_stack0">vstack（row_stack）函数：轴0(垂直)方向</h2>
<p><code>vstack(tup, dtype=None, casting="same_kind")</code></p>
<p>&lt;=&gt;<code>concatenate(arrays, axis=0)</code>（一维数组因无垂直方向，需转化为一行二维数组）</p>
<ol>
<li>
<p><strong>tup</strong>: 数组序列。这些数组除了轴0方向，其它轴方向上大小必须相同（注意一维数组轴的区别）</p>
</li>
<li>
<p>dtype: 同上</p>
</li>
<li>
<p>casting: 同上</p>
</li>
</ol>
<pre><code class="language-Python">n18 = np.array([1, 2, 3, 4])
n19 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n20 = np.vstack([n18, n19])
print(n20)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [11 12 13 14]
 [15 16 17 18]]
&quot;&quot;&quot;
</code></pre>
<h2 id="hstack1">hstack函数：轴1(水平)方向</h2>
<p><code>hstack(tup, dtype=None, casting="same_kind")</code></p>
<p>一维数组: &lt;=&gt;<code>concatenate(arrays, axis=0)</code></p>
<p>二维及以上数组: &lt;=&gt;<code>concatenate(arrays, axis=1)</code></p>
<ol>
<li>
<p><strong>tup</strong>: 同上。这些数组除了轴1方向，其它轴方向上大小必须相同（注意一维数组轴的区别）</p>
</li>
<li>
<p>dtype: 同上</p>
</li>
<li>
<p>casting: 同上</p>
</li>
</ol>
<pre><code class="language-Python">n21 = np.array([[1, 2, 3, 4, 5], [5, 6, 7, 8, 9]])
n22 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n23 = np.hstack([n21, n22])
print(n23)
&quot;&quot;&quot;
[[ 1  2  3  4  5 11 12 13 14]
 [ 5  6  7  8  9 15 16 17 18]]
&quot;&quot;&quot;
</code></pre>
<h2 id="dstack2">dstack函数：轴2方向</h2>
<p><code>dstack(tup, dtype=None, casting="same_kind")</code></p>
<p>&lt;=&gt;<code>concatenate(arrays, axis=2)</code>（只有三维数组有轴2，均需转换为三维数组）</p>
<ol>
<li>
<p><strong>tup</strong>: 同上。这些数组除了轴2方向，其它轴方向上大小必须相同（注意一维数组轴的区别）</p>
</li>
<li>
<p>dtype: 同上</p>
</li>
<li>
<p>casting: 同上</p>
</li>
</ol>
<pre><code class="language-Python">n24 = np.array([1, 2, 3, 4])
n25 = np.array([11, 12, 13, 14])
n26 = np.dstack([n24, n25])
print(n26)
&quot;&quot;&quot;
[[[ 1 11]
  [ 2 12]
  [ 3 13]
  [ 4 14]]]
&quot;&quot;&quot;

n27 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
n28 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n29 = np.dstack([n27, n28])
print(n29)
&quot;&quot;&quot;
[[[ 1 11]
  [ 2 12]
  [ 3 13]
  [ 4 14]]

 [[ 5 15]
  [ 6 16]
  [ 7 17]
  [ 8 18]]]
&quot;&quot;&quot;
</code></pre>
<h2 id="column_stack">column_stack函数</h2>
<p>一维数组将被转变为一列二维数组，然后进行水平拼接</p>
<p><code>column_stack(tup)</code></p>
<ol>
<li><strong>tup</strong>: 同上。注意垂直方向上大小匹配</li>
</ol>
<pre><code class="language-Python">n30 = np.array([1, 2, 3, 4])
n31 = np.array([11, 12, 13, 14])
n32 = np.column_stack([n30, n31])
print(n32)
&quot;&quot;&quot;
[[ 1 11]
 [ 2 12]
 [ 3 13]
 [ 4 14]]
&quot;&quot;&quot;

n33 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
n34 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n35 = np.column_stack([n33, n34])
print(n35)
&quot;&quot;&quot;
[[ 1  2  3  4 11 12 13 14]
 [ 5  6  7  8 15 16 17 18]]
&quot;&quot;&quot;

n36 = np.array([1, 2])
n37 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n38 = np.column_stack([n36, n37])
print(n38)
&quot;&quot;&quot;
[[ 1 11 12 13 14]
 [ 2 15 16 17 18]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_11">数组堆叠</h1>
<h2 id="stack">stack函数</h2>
<p><code>stack(arrays, axis=0, out=None, dtype=None, casting="same_kind")</code></p>
<ol>
<li>
<p><strong>arrays</strong>: <strong>形状相同</strong>的数组序列。这些数组形状必须相同，因所沿的轴为一个新轴</p>
</li>
<li>
<p><strong>axis</strong>: 指定新轴的索引，并沿该<strong>新轴</strong>进行堆叠。默认为0</p>
</li>
<li>
<p>out: 同上</p>
</li>
<li>
<p>dtype: 同上</p>
</li>
<li>
<p>casting: 同上</p>
</li>
</ol>
<pre><code class="language-Python"># 一维数组
n39 = np.array([1, 2, 3, 4])
n40 = np.array([11, 12, 13, 14])
n41 = np.stack([n39, n40], axis=0)    # 新轴为轴0（此时注意是二维数组的轴0），原轴0变为轴1，沿轴0堆叠
print(n41)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [11 12 13 14]]
&quot;&quot;&quot;

n42 = np.stack([n39, n40], axis=1)    # 新轴为轴1，原轴0仍为轴0（此时注意是二维数组的轴0），沿轴1堆叠
print(n42)
&quot;&quot;&quot;
[[ 1 11]
 [ 2 12]
 [ 3 13]
 [ 4 14]]
&quot;&quot;&quot;



# 二维数组
n43 = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])
n44 = np.array([[11, 12, 13, 14], [15, 16, 17, 18]])
n45 = np.stack([n43, n44], axis=0)    # 新轴为轴0，原轴0变为轴1，原轴1变为轴2，沿轴0堆叠
print(n45)
&quot;&quot;&quot;
[[[ 1  2  3  4]
  [ 5  6  7  8]]

 [[11 12 13 14]
  [15 16 17 18]]]
&quot;&quot;&quot;

n46 = np.stack([n43, n44], axis=1)    # 新轴为轴1，原轴0仍为轴0，原轴1变为轴2，沿轴0堆叠
print(n46)
&quot;&quot;&quot;
[[[ 1  2  3  4]
  [11 12 13 14]]

 [[ 5  6  7  8]
  [15 16 17 18]]]
&quot;&quot;&quot;

n47 = np.stack([n43, n44], axis=2)    # 新轴为轴2，原轴0仍为轴0，原轴1仍为轴1，沿轴2堆叠
print(n47)
&quot;&quot;&quot;
[[[ 1 11]
  [ 2 12]
  [ 3 13]
  [ 4 14]]

 [[ 5 15]
  [ 6 16]
  [ 7 17]
  [ 8 18]]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_12">数组拆分</h1>
<h2 id="split">split函数</h2>
<p><code>split(ary, indices_or_sections, axis=0)</code></p>
<ol>
<li>
<p><strong>ary</strong>: 待拆分的数组</p>
</li>
<li>
<p><strong>indices_or_sections</strong>: 整数或列表、数组等。如果是一个整数N，将沿轴拆分成N个相等大小的数组，若不能相等将报错；如果为列表、数组等，元素表示拆分的位置，如[2, 3]表示拆分为ary[:2]、ary[2:3]、ary[3:]，若超出索引将返回一个空的子数组</p>
</li>
<li>
<p><strong>axis</strong>: 拆分时沿的轴。默认为0</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.arange(15)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
&quot;&quot;&quot;

n1 = np.split(n0, 5)
print(n1)
&quot;&quot;&quot;
[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8]), array([ 9, 10, 11]), array([12, 13, 14])]
&quot;&quot;&quot;

n2 = np.split(n0, [3, 6, 7, 18])
print(n2)
&quot;&quot;&quot;
[array([0, 1, 2]), array([3, 4, 5]), array([6]), array([ 7,  8,  9, 10, 11, 12, 13, 14]), array([], dtype=int32)]
&quot;&quot;&quot;

n3 = np.arange(24).reshape([4, 6])
print(n3)
&quot;&quot;&quot;
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
&quot;&quot;&quot;

n4 = np.split(n3, 2, axis=0)
print(n4)
&quot;&quot;&quot;
[array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]]), 
 array([[12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])]
&quot;&quot;&quot;

n5 = np.split(n3, 2, axis=1)
print(n5)
&quot;&quot;&quot;
[array([[ 0,  1,  2],
       [ 6,  7,  8],
       [12, 13, 14],
       [18, 19, 20]]), 
 array([[ 3,  4,  5],
       [ 9, 10, 11],
       [15, 16, 17],
       [21, 22, 23]])]
&quot;&quot;&quot;
</code></pre>
<h2 id="vsplit0">vsplit函数：轴0方向或垂直方向</h2>
<p><strong>仅用于二维及以上数组</strong></p>
<p><code>vsplit(ary, indices_or_sections)</code></p>
<p>&lt;=&gt;<code>split(ary, indices_or_sections, axis=0)</code></p>
<pre><code class="language-Python">n6 = np.arange(24).reshape([4, 6])
print(n6)
&quot;&quot;&quot;
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
&quot;&quot;&quot;

n7 = np.vsplit(n6, 2)
print(n7)
&quot;&quot;&quot;
[array([[ 0,  1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10, 11]]), 
 array([[12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])]
&quot;&quot;&quot;
</code></pre>
<h2 id="hsplit1">hsplit函数：轴1方向或水平方向</h2>
<p><strong>一维数组沿轴0方向，二维及以上数组沿轴1方向</strong></p>
<p><code>hsplit(ary, indices_or_sections)</code></p>
<p>一维数组：&lt;=&gt;<code>split(ary, indices_or_sections, axis=0)</code></p>
<p>二维及以上数组：&lt;=&gt;<code>split(ary, indices_or_sections, axis=1)</code></p>
<pre><code class="language-Python">n8 = np.arange(15)
print(n8)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
&quot;&quot;&quot;

n9 = np.hsplit(n8, 5)
print(n9)
&quot;&quot;&quot;
[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8]), array([ 9, 10, 11]), array([12, 13, 14])]
&quot;&quot;&quot;

n01 = np.arange(24).reshape([4, 6])
print(n10)
&quot;&quot;&quot;
[[ 0  1  2  3  4  5]
 [ 6  7  8  9 10 11]
 [12 13 14 15 16 17]
 [18 19 20 21 22 23]]
&quot;&quot;&quot;

n11 = np.hsplit(n10, 2)
print(n11)
&quot;&quot;&quot;
[array([[ 0,  1,  2],
       [ 6,  7,  8],
       [12, 13, 14],
       [18, 19, 20]]), 
 array([[ 3,  4,  5],
       [ 9, 10, 11],
       [15, 16, 17],
       [21, 22, 23]])]
&quot;&quot;&quot;
</code></pre>
<h2 id="dsplit2">dsplit函数：轴2方向</h2>
<p><strong>仅用于三维及以上数组</strong></p>
<p><code>dsplit(ary, indices_or_sections)</code></p>
<p>&lt;=&gt;<code>split(ary, indices_or_sections, axis=2)</code></p>
<pre><code class="language-Python">n12 = np.arange(16).reshape([2, 2, 4])
print(n12)
&quot;&quot;&quot;
[[[ 0  1  2  3]
  [ 4  5  6  7]]

 [[ 8  9 10 11]
  [12 13 14 15]]]
&quot;&quot;&quot;

n13 = np.dsplit(n12, 2)
print(n13)
&quot;&quot;&quot;
[array([[[ 0,  1],
        [ 4,  5]],

       [[ 8,  9],
        [12, 13]]]), 
 array([[[ 2,  3],
        [ 6,  7]],

       [[10, 11],
        [14, 15]]])]
&quot;&quot;&quot;
</code></pre>
<h2 id="array_split">array_split函数</h2>
<p>与split函数类似，区别是当不能分成相等大小的子数组时不会报错</p>
<p><code>array_split(ary, indices_or_sections, axis=0)</code></p>
<ol>
<li>
<p><strong>ary</strong>: 同上</p>
</li>
<li>
<p><strong>indices_or_sections</strong>: 同上。在某一轴上，长度为L，拆分成N个部分，返回L%N个该轴上长度为L//N+1的子数组，其余子数组该轴上长度为L//N</p>
</li>
<li>
<p><strong>axis</strong>: 同上</p>
</li>
</ol>
<pre><code class="language-Python">n14 = np.arange(15)
print(n14)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
&quot;&quot;&quot;

n15 = np.array_split(n14, 4)    #15%4=3个长度为15//4+1=4的子数组和4-3=1个长度为15//4=3的子数组
print(n15)
&quot;&quot;&quot;
[array([0, 1, 2, 3]), array([4, 5, 6, 7]), array([ 8,  9, 10, 11]), array([12, 13, 14])]
&quot;&quot;&quot;
</code></pre>
<h1 id="_13">数组删除</h1>
<p>简单的方式可通过索引和切片选取所需数组或元素即可</p>
<h2 id="delete">delete函数</h2>
<p>返回一个数组，该数组删除了原数组沿指定轴指定索引的数组</p>
<p><code>delete(arr, obj, axis=None)</code></p>
<ol>
<li>
<p><strong>arr</strong>: 待删除数据的数组</p>
</li>
<li>
<p><strong>obj</strong>: 指定沿axis要删除的索引</p>
</li>
<li>
<p><strong>axis</strong>: 指定删除时所沿的轴。若axis为None，则将数组整体视为一维数组，返回结果也为一维数组</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [11, 12, 13, 14], [15, 16, 17, 18]])
print(n0)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [ 5  6  7  8]
 [11 12 13 14]
 [15 16 17 18]]
&quot;&quot;&quot;

n1 = np.delete(n0, 1, axis=0)    # 删除第2行
print(n1)
&quot;&quot;&quot;
[[ 1  2  3  4]
 [11 12 13 14]
 [15 16 17 18]]
&quot;&quot;&quot;

n2 = np.delete(n0, 1, axis=1)    # 删除第2列
print(n2)
&quot;&quot;&quot;
[[ 1  3  4]
 [ 5  7  8]
 [11 13 14]
 [15 17 18]]
&quot;&quot;&quot;

n3 = np.delete(n0, [0, 2], axis=1)    # 删除第1和第3列
print(n3)
&quot;&quot;&quot;
[[ 2  4]
 [ 6  8]
 [12 14]
 [16 18]]
&quot;&quot;&quot;

n4 = np.delete(n0, [1, 3, 5, 7], axis=None)    # 删除第2、4、6、8个
print(n4)
&quot;&quot;&quot;
[ 1  3  5  7 11 12 13 14 15 16 17 18]
&quot;&quot;&quot;
</code></pre>
<h1 id="_14">数组修改</h1>
<p>直接索引或切片后赋值即可</p>
<pre><code class="language-Python">n0 = np.arange(12).reshape(3, 4)
print(n0)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
&quot;&quot;&quot;

n0[2] = 20
print(n0)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5  6  7]
 [20 20 20 20]]
&quot;&quot;&quot;

n0[1, 2] = 60
print(n0)
&quot;&quot;&quot;
[[ 0  1  2  3]
 [ 4  5 60  7]
 [20 20 20 20]]
&quot;&quot;&quot;

n0[:2, 2:] = [[20, 30], [600, 70]]
print(n0)
&quot;&quot;&quot;
[[  0   1  20  30]
 [  4   5 600  70]
 [ 20  20  20  20]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_15">数组查询</h1>
<h2 id="where">where函数</h2>
<p><code>where(condition, x=None, y=None)</code></p>
<ol>
<li>
<p><strong>condition</strong>: 条件。当只有该参数时，结果返回满足条件的元素数组元组</p>
</li>
<li>
<p><strong>x</strong>: 单一值或数组。条件为True的值用x或x中对应的值替换。遵循广播机制</p>
</li>
<li>
<p><strong>y</strong>: 单一数值或数组。条件为False的值用y或y中对应的值替换。遵循广播机制</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.arange(12)
print(n0)
&quot;&quot;&quot;
[ 0  1  2  3  4  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n1 = np.where(n0 &gt;= 5)
print(n1)
&quot;&quot;&quot;
(array([ 5,  6,  7,  8,  9, 10, 11], dtype=int64),)
&quot;&quot;&quot;

n1 = np.where(n0 &gt;= 5, n0, n0+5)
print(n1)
&quot;&quot;&quot;
[ 5  6  7  8  9  5  6  7  8  9 10 11]
&quot;&quot;&quot;

n2 = np.where(n0 &gt;= 5, 1, 0)
print(n2)
&quot;&quot;&quot;
[0 0 0 0 0 1 1 1 1 1 1 1]
&quot;&quot;&quot;

n3 = np.array([[0], [1], [2]])
print(n3)
&quot;&quot;&quot;
[[0]
 [1]
 [2]]
&quot;&quot;&quot;

n4 = np.array([0, 1, 2, 3])
print(n4)
&quot;&quot;&quot;
[0 1 2 3]
&quot;&quot;&quot;

n5 = np.where(n3 &lt; n4, 2 * n3, 10 + n4)
print(n5)
&quot;&quot;&quot;
[[10  0  0  0]
 [10 11  2  2]
 [10 11 12  4]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_16">对角提取</h1>
<p>至少是二维数组</p>
<p>二维数组：直接提取对角，即a[i, i+offset]（注意轴的改变）</p>
<p>多维数组：先根据axis1和axis2提取出多个二维数组，再提取每个二维数组的对角</p>
<h2 id="diagonal">diagonal方法</h2>
<p><code>ndarray.diagonal(offset=0, axis1=0, axis2=1)</code></p>
<ol>
<li>
<p><strong>offset</strong>: 相对于主对角线的偏移量或者对角线索引。默认为0，即主对角线；+表示上方对角线，-表示下方对角线</p>
</li>
<li>
<p><strong>axis1</strong>: 作为提取出的二维数组的轴0</p>
</li>
<li>
<p><strong>axis2</strong>: 作为提取出的二维数组的轴1</p>
</li>
</ol>
<pre><code class="language-Python"># 二维数组
n0 = np.random.randint(1, 10, size=(5, 9))
print(n0)
&quot;&quot;&quot;
[[3 4 9 9 5 7 9 3 4]
 [3 7 1 5 8 6 2 5 9]
 [8 2 5 3 8 1 7 6 7]
 [3 5 4 2 3 5 5 2 6]
 [5 8 1 4 6 7 1 5 1]]
&quot;&quot;&quot;

n1 = n0.diagonal()
print(n1)
&quot;&quot;&quot;
[3 7 5 2 6]
&quot;&quot;&quot;

n2 = n0.diagonal(offset=1)
print(n2)
&quot;&quot;&quot;
[4 1 3 3 7]
&quot;&quot;&quot;

n3 = n0.diagonal(offset=-1)
print(n3)
&quot;&quot;&quot;
[3 2 4 4]
&quot;&quot;&quot;

n4 = n0.diagonal(offset=1, axis1=0, axis2=1)
print(n4)
&quot;&quot;&quot;
[4 1 3 3 7]
&quot;&quot;&quot;

n5 = n0.diagonal(offset=1, axis1=1, axis2=0)
print(n5)
&quot;&quot;&quot;
[3 2 4 4]
&quot;&quot;&quot;



# 三维数组
n6 = np.random.randint(1, 10, size=(3, 4, 5))
print(n6)
&quot;&quot;&quot;
[[[4 9 6 8 8]
  [4 6 3 4 4]
  [6 8 4 2 7]
  [3 3 6 8 5]]

 [[8 3 1 8 6]
  [1 6 5 1 1]
  [9 1 3 1 4]
  [7 3 5 8 8]]

 [[1 1 4 1 7]
  [2 1 6 3 6]
  [4 5 6 9 9]
  [1 5 5 7 4]]]
&quot;&quot;&quot;

n7 = n6.diagonal(axis1=2, axis2=1)
print(n7)
&quot;&quot;&quot;
[[4 6 4 8]
 [8 6 3 8]
 [1 1 6 7]]
&quot;&quot;&quot;
</code></pre>
<h2 id="diagonal_1">diagonal函数</h2>
<p><code>diagonal(a, offset=0, axis1=0, axis2=1)</code></p>
<ol>
<li>
<p><strong>a</strong>: 待提取的数组，至少为二维数组</p>
</li>
<li>
<p><strong>offset</strong>: 同上</p>
</li>
<li>
<p><strong>axis1</strong>: 同上</p>
</li>
<li>
<p><strong>axis2</strong>: 同上</p>
</li>
</ol>
<pre><code class="language-Python"># 二维数组
n8 = np.random.randint(1, 10, size=(5, 9))
print(n8)
&quot;&quot;&quot;
[[7 4 3 7 1 2 3 1 4]
 [7 1 9 1 1 9 8 3 4]
 [3 8 4 8 2 8 3 4 4]
 [2 3 9 2 2 3 1 5 1]
 [5 5 2 2 7 4 9 7 3]]
&quot;&quot;&quot;

n9 = np.diagonal(n8)
print(n9)
&quot;&quot;&quot;
[7 1 4 2 7]
&quot;&quot;&quot;



# 三维数组
n10 = np.random.randint(1, 10, size=(3, 4, 5))
print(n10)
&quot;&quot;&quot;
[[[2 2 9 2 6]
  [2 2 4 5 5]
  [9 2 1 5 3]
  [8 5 7 3 9]]

 [[3 4 4 1 4]
  [4 9 5 9 7]
  [5 8 6 4 1]
  [9 6 6 3 2]]

 [[2 1 1 6 3]
  [4 6 6 4 7]
  [8 9 2 5 9]
  [1 8 7 8 9]]]
&quot;&quot;&quot;

n11 = np.diagonal(n10, axis1=2, axis2=1)
print(n11)
&quot;&quot;&quot;
[[2 2 1 3]
 [3 9 6 3]
 [2 6 2 8]]
&quot;&quot;&quot;
</code></pre>
<h2 id="diag">diag函数</h2>
<p>见数组的对角创建</p>
<h1 id="_17">对角修改</h1>
<h2 id="fill_diagonal">fill_diagonal函数</h2>
<p><strong>主对角线</strong>a[i, i, ..., i]被修改为val，无返回值，<strong>直接修改原数组</strong></p>
<p><code>fill_diagonal(a, val, wrap=False)</code></p>
<ol>
<li>
<p><strong>a</strong>: 待修改数组，至少是二维数组。对于<strong>多维数组，每个维度上大小必需都相同</strong></p>
</li>
<li>
<p><strong>val</strong>: 如果val是单一数值，该值沿着主对角线重复写入；如果为数组，该数组被转化为一维数组后重复写入主对角线</p>
</li>
<li>
<p><strong>wrap</strong>: 溢出是否换行（一般只有高的二维数组会溢出）。默认为False</p>
</li>
</ol>
<pre><code class="language-Python"># 二维数组
n0 = np.zeros([10, 5])
print(n0)
&quot;&quot;&quot;
[[0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]]
&quot;&quot;&quot;

np.fill_diagonal(n0, 5)
print(n0)
&quot;&quot;&quot;
[[5. 0. 0. 0. 0.]
 [0. 5. 0. 0. 0.]
 [0. 0. 5. 0. 0.]
 [0. 0. 0. 5. 0.]
 [0. 0. 0. 0. 5.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]]
&quot;&quot;&quot;

np.fill_diagonal(n0, [1, 2, 3])
print(n0)
&quot;&quot;&quot;
[[1. 0. 0. 0. 0.]
 [0. 2. 0. 0. 0.]
 [0. 0. 3. 0. 0.]
 [0. 0. 0. 1. 0.]
 [0. 0. 0. 0. 2.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]]
&quot;&quot;&quot;

np.fill_diagonal(n0, [[5, 6], [7, 8]])
print(n0)
&quot;&quot;&quot;
[[5. 0. 0. 0. 0.]
 [0. 6. 0. 0. 0.]
 [0. 0. 7. 0. 0.]
 [0. 0. 0. 8. 0.]
 [0. 0. 0. 0. 5.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]]
&quot;&quot;&quot;

np.fill_diagonal(n0, 5, wrap=True)
print(n0)
&quot;&quot;&quot;
[[5. 0. 0. 0. 0.]
 [0. 5. 0. 0. 0.]
 [0. 0. 5. 0. 0.]
 [0. 0. 0. 5. 0.]
 [0. 0. 0. 0. 5.]
 [0. 0. 0. 0. 0.]
 [5. 0. 0. 0. 0.]
 [0. 5. 0. 0. 0.]
 [0. 0. 5. 0. 0.]
 [0. 0. 0. 5. 0.]]
&quot;&quot;&quot;



# 三维数组
n1 = np.zeros([4, 4, 4])
print(n1)
&quot;&quot;&quot;
[[[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]]
&quot;&quot;&quot;

np.fill_diagonal(n1, 5)
print(n1)
&quot;&quot;&quot;
[[[5. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 5. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 5. 0.]
  [0. 0. 0. 0.]]

 [[0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 0.]
  [0. 0. 0. 5.]]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_18">对角三角提取</h1>
<p>一维数组：先扩展为轴0和轴1相同大小的二维数组，再提取提取指定对角线以上或以下部分</p>
<p>二维数组：提取指定对角线以上或以下部分，其余部分为0</p>
<p>多维数组：以最后两个轴提取出多个二维数组，再提取每个二维数组指定对角线以上或以下部分</p>
<h2 id="trillower">tril函数：对角线以下(lower)</h2>
<p><code>tril(m, k=0)</code></p>
<ol>
<li>
<p><strong>m</strong>: 待提取数组</p>
</li>
<li>
<p><strong>k</strong>: 同offset</p>
</li>
</ol>
<pre><code class="language-Python"># 一维数组
n0 = np.arange(1, 10)
print(n0)
&quot;&quot;&quot;
[1 2 3 4 5 6 7 8 9]
&quot;&quot;&quot;

n1 = np.tril(n0)
print(n1)
&quot;&quot;&quot;
[[1 0 0 0 0 0 0 0 0]
 [1 2 0 0 0 0 0 0 0]
 [1 2 3 0 0 0 0 0 0]
 [1 2 3 4 0 0 0 0 0]
 [1 2 3 4 5 0 0 0 0]
 [1 2 3 4 5 6 0 0 0]
 [1 2 3 4 5 6 7 0 0]
 [1 2 3 4 5 6 7 8 0]
 [1 2 3 4 5 6 7 8 9]]
&quot;&quot;&quot;



# 二维数组
n2 = np.random.randint(1, 10, size=(4, 5))
print(n2)
&quot;&quot;&quot;
[[4 3 2 9 1]
 [2 3 1 9 7]
 [8 9 3 4 1]
 [7 4 6 7 5]]
&quot;&quot;&quot;

n3 = np.tril(n2)
print(n3)
&quot;&quot;&quot;
[[4 0 0 0 0]
 [2 3 0 0 0]
 [8 9 3 0 0]
 [7 4 6 7 0]]
&quot;&quot;&quot;



# 三维数组
n4 = np.random.randint(1, 10, size=(4, 5, 6))
print(n4)
&quot;&quot;&quot;
[[[3 6 8 8 4 5]
  [4 8 1 8 5 3]
  [7 1 7 7 6 8]
  [7 5 7 4 4 6]
  [4 2 1 5 9 5]]

 [[5 8 6 1 1 5]
  [7 5 1 7 4 5]
  [4 9 2 9 1 3]
  [9 4 3 5 4 5]
  [7 3 7 2 6 4]]

 [[9 9 7 4 1 7]
  [9 4 4 9 7 8]
  [5 8 4 9 7 4]
  [7 7 2 9 3 9]
  [5 2 8 1 9 1]]

 [[6 7 8 8 7 7]
  [9 9 5 1 5 3]
  [7 3 3 9 8 1]
  [7 3 1 2 4 9]
  [7 1 9 9 7 8]]]
&quot;&quot;&quot;

n5 = np.tril(n4)
print(n5)
&quot;&quot;&quot;
[[[3 0 0 0 0 0]
  [4 8 0 0 0 0]
  [7 1 7 0 0 0]
  [7 5 7 4 0 0]
  [4 2 1 5 9 0]]

 [[5 0 0 0 0 0]
  [7 5 0 0 0 0]
  [4 9 2 0 0 0]
  [9 4 3 5 0 0]
  [7 3 7 2 6 0]]

 [[9 0 0 0 0 0]
  [9 4 0 0 0 0]
  [5 8 4 0 0 0]
  [7 7 2 9 0 0]
  [5 2 8 1 9 0]]

 [[6 0 0 0 0 0]
  [9 9 0 0 0 0]
  [7 3 3 0 0 0]
  [7 3 1 2 0 0]
  [7 1 9 9 7 0]]]
&quot;&quot;&quot;
</code></pre>
<h2 id="triuupper">triu函数：对角线以上(upper)</h2>
<p><code>triu(m, k=0)</code></p>
<ol>
<li>
<p><strong>m</strong>: 待提取数组</p>
</li>
<li>
<p><strong>k</strong>: 同offset</p>
</li>
</ol>
<pre><code class="language-Python"># 一维数组
n5 = np.arange(1, 10)
print(n5)
&quot;&quot;&quot;
[1 2 3 4 5 6 7 8 9]
&quot;&quot;&quot;

n6 = np.triu(n5)
print(n6)
&quot;&quot;&quot;
[[1 2 3 4 5 6 7 8 9]
 [0 2 3 4 5 6 7 8 9]
 [0 0 3 4 5 6 7 8 9]
 [0 0 0 4 5 6 7 8 9]
 [0 0 0 0 5 6 7 8 9]
 [0 0 0 0 0 6 7 8 9]
 [0 0 0 0 0 0 7 8 9]
 [0 0 0 0 0 0 0 8 9]
 [0 0 0 0 0 0 0 0 9]]
&quot;&quot;&quot;



# 二维数组
n7 = np.random.randint(1, 10, size=(4, 5))
print(n7)
&quot;&quot;&quot;
[[3 9 7 8 5]
 [5 1 6 8 4]
 [1 6 8 8 1]
 [6 5 6 9 3]]
&quot;&quot;&quot;

n8 = np.triu(n7)
print(n8)
&quot;&quot;&quot;
[[3 9 7 8 5]
 [0 1 6 8 4]
 [0 0 8 8 1]
 [0 0 0 9 3]]
&quot;&quot;&quot;



# 三维数组
n9 = np.random.randint(1, 10, size=(4, 5, 6))
print(n9)
&quot;&quot;&quot;
[[[3 7 9 2 5 3]
  [6 5 3 1 7 7]
  [2 1 8 8 8 1]
  [3 1 6 6 5 4]
  [6 4 3 8 2 9]]

 [[2 5 7 1 6 9]
  [8 8 5 6 4 8]
  [8 5 7 5 1 8]
  [9 9 7 2 5 6]
  [2 2 8 2 7 4]]

 [[7 9 1 4 8 3]
  [2 1 9 6 5 6]
  [8 5 8 2 9 7]
  [5 1 5 6 6 8]
  [5 5 7 3 5 2]]

 [[3 5 9 6 2 3]
  [1 8 6 2 9 4]
  [3 5 1 4 4 5]
  [2 6 7 9 8 4]
  [7 4 4 2 5 3]]]
&quot;&quot;&quot;

n10 = np.triu(n9)
print(n10)
&quot;&quot;&quot;
[[[3 7 9 2 5 3]
  [0 5 3 1 7 7]
  [0 0 8 8 8 1]
  [0 0 0 6 5 4]
  [0 0 0 0 2 9]]

 [[2 5 7 1 6 9]
  [0 8 5 6 4 8]
  [0 0 7 5 1 8]
  [0 0 0 2 5 6]
  [0 0 0 0 7 4]]

 [[7 9 1 4 8 3]
  [0 1 9 6 5 6]
  [0 0 8 2 9 7]
  [0 0 0 6 6 8]
  [0 0 0 0 5 2]]

 [[3 5 9 6 2 3]
  [0 8 6 2 9 4]
  [0 0 1 4 4 5]
  [0 0 0 9 8 4]
  [0 0 0 0 5 3]]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_19">数组翻转/旋转</h1>
<h2 id="flip">flip函数</h2>
<p>逆转数组沿着指定轴元素的顺序，即m[..., <strong>::-1</strong>, ...]</p>
<p><code>flip(m, axis=None)</code></p>
<ol>
<li>
<p><strong>m</strong>: 待翻转数组</p>
</li>
<li>
<p><strong>axis</strong>: 指定轴，可以是一条轴也可以是多条轴。默认是None，将翻转数组的所有轴</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.random.randint(1, 10, size=(3, 4, 5))
print(n0)
&quot;&quot;&quot;
[[[1 7 8 7 7]
  [6 2 8 8 3]
  [8 1 1 5 1]
  [1 8 4 8 9]]

 [[2 3 3 2 5]
  [2 2 3 1 4]
  [8 6 3 5 6]
  [4 1 6 2 2]]

 [[8 2 1 4 2]
  [4 1 7 8 2]
  [9 5 2 7 3]
  [1 8 4 5 1]]]
&quot;&quot;&quot;

n1 = np.flip(n0)
print(n1)
&quot;&quot;&quot;
[[[1 5 4 8 1]
  [3 7 2 5 9]
  [2 8 7 1 4]
  [2 4 1 2 8]]

 [[2 2 6 1 4]
  [6 5 3 6 8]
  [4 1 3 2 2]
  [5 2 3 3 2]]

 [[9 8 4 8 1]
  [1 5 1 1 8]
  [3 8 8 2 6]
  [7 7 8 7 1]]]
&quot;&quot;&quot;

n2 = np.flip(n0, axis=0)
print(n2)
&quot;&quot;&quot;
[[[8 2 1 4 2]
  [4 1 7 8 2]
  [9 5 2 7 3]
  [1 8 4 5 1]]

 [[2 3 3 2 5]
  [2 2 3 1 4]
  [8 6 3 5 6]
  [4 1 6 2 2]]

 [[1 7 8 7 7]
  [6 2 8 8 3]
  [8 1 1 5 1]
  [1 8 4 8 9]]]
&quot;&quot;&quot;

n3 = np.flip(n0, axis=1)
print(n3)
&quot;&quot;&quot;
[[[1 8 4 8 9]
  [8 1 1 5 1]
  [6 2 8 8 3]
  [1 7 8 7 7]]

 [[4 1 6 2 2]
  [8 6 3 5 6]
  [2 2 3 1 4]
  [2 3 3 2 5]]

 [[1 8 4 5 1]
  [9 5 2 7 3]
  [4 1 7 8 2]
  [8 2 1 4 2]]]
&quot;&quot;&quot;

n4 = np.flip(n0, axis=2)
print(n4)
&quot;&quot;&quot;
[[[7 7 8 7 1]
  [3 8 8 2 6]
  [1 5 1 1 8]
  [9 8 4 8 1]]

 [[5 2 3 3 2]
  [4 1 3 2 2]
  [6 5 3 6 8]
  [2 2 6 1 4]]

 [[2 4 1 2 8]
  [2 8 7 1 4]
  [3 7 2 5 9]
  [1 5 4 8 1]]]
&quot;&quot;&quot;

n5 = np.flip(n0, axis=(1, 2))
print(n5)
&quot;&quot;&quot;
[[[9 8 4 8 1]
  [1 5 1 1 8]
  [3 8 8 2 6]
  [7 7 8 7 1]]

 [[2 2 6 1 4]
  [6 5 3 6 8]
  [4 1 3 2 2]
  [5 2 3 3 2]]

 [[1 5 4 8 1]
  [3 7 2 5 9]
  [2 8 7 1 4]
  [2 4 1 2 8]]]
&quot;&quot;&quot;

n6 = n0[:, ::-1, ::-1]    # 与n5等价
print(n6)
&quot;&quot;&quot;
[[[9 8 4 8 1]
  [1 5 1 1 8]
  [3 8 8 2 6]
  [7 7 8 7 1]]

 [[2 2 6 1 4]
  [6 5 3 6 8]
  [4 1 3 2 2]
  [5 2 3 3 2]]

 [[1 5 4 8 1]
  [3 7 2 5 9]
  [2 8 7 1 4]
  [2 4 1 2 8]]]
&quot;&quot;&quot;
</code></pre>
<h2 id="fliplr">fliplr函数</h2>
<p>将数组（至少是二维数组）沿<strong>轴1</strong>（二维：left/right）翻转</p>
<p><code>fliplr(m)</code></p>
<p>&lt;=&gt;<code>flip(m, axis=1)</code></p>
<p>&lt;=&gt;<code>m[:, ::-1]</code></p>
<pre><code class="language-Python">n0 = np.random.randint(1, 10, size=(3, 4, 5))
print(n0)
&quot;&quot;&quot;
[[[1 4 5 2 3]
  [7 3 7 8 9]
  [2 1 6 3 7]
  [9 6 3 1 1]]

 [[7 9 2 4 7]
  [3 5 9 3 8]
  [9 9 6 5 2]
  [8 9 1 8 2]]

 [[9 9 1 7 6]
  [7 1 2 8 5]
  [8 1 2 2 4]
  [4 5 6 2 4]]]
&quot;&quot;&quot;

n7 = np.fliplr(n0)
print(n7)
&quot;&quot;&quot;
[[[9 6 3 1 1]
  [2 1 6 3 7]
  [7 3 7 8 9]
  [1 4 5 2 3]]

 [[8 9 1 8 2]
  [9 9 6 5 2]
  [3 5 9 3 8]
  [7 9 2 4 7]]

 [[4 5 6 2 4]
  [8 1 2 2 4]
  [7 1 2 8 5]
  [9 9 1 7 6]]]
&quot;&quot;&quot;
</code></pre>
<h2 id="flipud">flipud函数</h2>
<p>将数组（至少是一维数组）沿<strong>轴0</strong>（二维：up/down）翻转</p>
<p><code>flipud(m)</code></p>
<p>&lt;=&gt;<code>flip(m, axis=0)</code></p>
<p>&lt;=&gt;<code>m[::-1, ...]</code></p>
<pre><code class="language-Python">n0 = np.random.randint(1, 10, size=(3, 4, 5))
print(n0)
&quot;&quot;&quot;
[[[4 5 1 2 6]
  [8 7 4 8 9]
  [9 9 2 8 2]
  [5 3 7 9 8]]

 [[3 8 5 3 2]
  [4 2 3 2 3]
  [2 5 7 3 6]
  [8 3 9 9 3]]

 [[9 2 7 7 2]
  [8 3 6 6 2]
  [1 8 6 1 1]
  [3 9 5 2 6]]]
&quot;&quot;&quot;

n8 = np.flipud(n0)
print(n8)
&quot;&quot;&quot;
[[[9 2 7 7 2]
  [8 3 6 6 2]
  [1 8 6 1 1]
  [3 9 5 2 6]]

 [[3 8 5 3 2]
  [4 2 3 2 3]
  [2 5 7 3 6]
  [8 3 9 9 3]]

 [[4 5 1 2 6]
  [8 7 4 8 9]
  [9 9 2 8 2]
  [5 3 7 9 8]]]
&quot;&quot;&quot;
</code></pre>
<h2 id="rot90">rot90函数</h2>
<p>将数组（至少是二维数组）从第一个轴向第二个轴旋转k个90°。多维数组即将多维数组中有指定两个轴的二维数组进行旋转</p>
<p><code>rot90(m, k=1, axes=(0, 1))</code></p>
<ol>
<li>
<p><strong>m</strong>: 待旋转数组</p>
</li>
<li>
<p><strong>k</strong>: 旋转次数</p>
</li>
<li>
<p><strong>axes</strong>: 轴序列。<strong>必须且只能是指定两个轴，并且两个轴必须不同</strong>。</p>
</li>
</ol>
<p><img alt="image.png" src="image%201.png" /></p>
<pre><code class="language-Python">n0 = np.random.randint(1, 10, size=(3, 4))
print(n0)
&quot;&quot;&quot;
[[7 6 1 6]
 [2 7 9 5]
 [2 8 7 4]]
&quot;&quot;&quot;

n9 = np.rot90(n0)
print(n9)
&quot;&quot;&quot;
[[6 5 4]
 [1 9 7]
 [6 7 8]
 [7 2 2]]
&quot;&quot;&quot;

n10 = np.rot90(n0, k=2)
print(n10)
&quot;&quot;&quot;
[[4 7 8 2]
 [5 9 7 2]
 [6 1 6 7]]
&quot;&quot;&quot;

n11 = np.rot90(n0, axes=(1, 0))
print(n11)
&quot;&quot;&quot;
[[2 2 7]
 [8 7 6]
 [7 9 1]
 [4 5 6]]
&quot;&quot;&quot;

n12 = np.random.randint(1, 10, size=(3, 4, 5))
print(n12)
&quot;&quot;&quot;
[[[4 9 8 3 8]
  [6 2 3 8 1]
  [7 9 5 3 8]
  [1 5 6 5 7]]

 [[8 5 1 7 4]
  [5 3 4 4 1]
  [4 6 3 2 1]
  [5 3 8 8 7]]

 [[1 8 2 2 3]
  [9 1 9 2 4]
  [2 1 3 9 5]
  [3 5 5 8 5]]]
&quot;&quot;&quot;

n13 = np.rot90(n12, axes=(1, 2))
print(n13)
&quot;&quot;&quot;
[[[8 1 8 7]
  [3 8 3 5]
  [8 3 5 6]
  [9 2 9 5]
  [4 6 7 1]]

 [[4 1 1 7]
  [7 4 2 8]
  [1 4 3 8]
  [5 3 6 3]
  [8 5 4 5]]

 [[3 4 5 5]
  [2 2 9 8]
  [2 9 3 5]
  [8 1 1 5]
  [1 9 2 3]]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_20">数组排序</h1>
<h2 id="sort">sort方法、函数</h2>
<p><code>ndarray.sort(axis=-1, kind=None, order=None)</code>
<code>sort(a, axis=-1, kind=None, order=None)</code>
sort方法对原数组进行排序，而sort函数返回排序后的副本</p>
<ol>
<li>
<p><strong>a</strong>: 待排序的数组</p>
</li>
<li>
<p><strong>axis</strong>: 排序指定的轴。默认为-1，即对最后一个轴进行排序。若为None，则将数组视为一维数组进行排序</p>
</li>
<li>
<p>kind: 排序算法。可选'quicksort'（默认）、'mergesort'、 'heapsort'、 'stable'</p>
</li>
<li>
<p><strong>order</strong>: 指定排序的字段。适用于结构化数组。当指定多个字段时，若前一个字段排序时相同，再根据后一个字段进行排序</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.random.randint(1, 17, size=(2, 2, 4))
print(n0)
&quot;&quot;&quot;
[[[16  3  2 11]
  [16  3  8 11]]

 [[ 5  5  2 11]
  [14  8  8  9]]]
&quot;&quot;&quot;

n0.sort()
print(n0)
&quot;&quot;&quot;
[[[ 2  3 11 16]
  [ 3  8 11 16]]

 [[ 2  5  5 11]
  [ 8  8  9 14]]]
&quot;&quot;&quot;

n0 = np.random.randint(1, 17, size=(2, 2, 4))
print(n0)
&quot;&quot;&quot;
[[[ 1  7  4 11]
  [ 8 12  5 11]]

 [[11  8  4 11]
  [ 9 12  5 13]]]
&quot;&quot;&quot;

n2 = np.sort(n0)
print(n2)
&quot;&quot;&quot;
[[[ 1  4  7 11]
  [ 5  8 11 12]]

 [[ 4  8 11 11]
  [ 5  9 12 13]]]
&quot;&quot;&quot;

n3 = np.sort(n0, axis=0)
print(n3)
&quot;&quot;&quot;
[[[ 1  7  4 11]
  [ 8 12  5 11]]

 [[11  8  4 11]
  [ 9 12  5 13]]]
&quot;&quot;&quot;

n4 = np.sort(n0, axis=1)
print(n4)
&quot;&quot;&quot;
[[[ 1  7  4 11]
  [ 8 12  5 11]]

 [[ 9  8  4 11]
  [11 12  5 13]]]
&quot;&quot;&quot;

n5 = np.sort(n0, axis=2)
print(n5)
&quot;&quot;&quot;
[[[ 1  4  7 11]
  [ 5  8 11 12]]

 [[ 4  8 11 11]
  [ 5  9 12 13]]]
&quot;&quot;&quot;

n6 = np.sort(n0, axis=None)
print(n6)
&quot;&quot;&quot;
[ 1  4  4  5  5  7  8  8  9 11 11 11 11 12 12 13]
&quot;&quot;&quot;



dtype = [('name', 'S10'), ('height', float), ('age', int)]
values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38), ('Galahad', 1.7, 38)]
n7 = np.array(values, dtype=dtype)
print(n7)
&quot;&quot;&quot;
[(b'Arthur', 1.8, 41) (b'Lancelot', 1.9, 38) (b'Galahad', 1.7, 38)]
&quot;&quot;&quot;

print(np.sort(n7, order='height'))
&quot;&quot;&quot;
[(b'Galahad', 1.7, 38) (b'Arthur', 1.8, 41) (b'Lancelot', 1.9, 38)]
&quot;&quot;&quot;

print(np.sort(n7, order=['age', 'height']))
&quot;&quot;&quot;
[(b'Galahad', 1.7, 38) (b'Lancelot', 1.9, 38) (b'Arthur', 1.8, 41)]
&quot;&quot;&quot;
</code></pre>
<h2 id="argsort">argsort方法、函数</h2>
<p>返回排序后的各元素在原数组中沿指定轴的位置，但实际并不对数组进行排序</p>
<p><code>ndarray.argsort(axis=-1, kind=None, order=None)</code>
<code>argsort(a, axis=-1, kind=None, order=None)</code></p>
<ol>
<li>
<p><strong>a</strong>: 同上</p>
</li>
<li>
<p><strong>axis</strong>: 同上</p>
</li>
<li>
<p>kind: 同上</p>
</li>
<li>
<p><strong>order</strong>: 同上</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.random.randint(1, 17, size=(2, 2, 4))
print(n0)
&quot;&quot;&quot;
[[[ 6  5  6  7]
  [16 10  9  1]]

 [[ 1 11  9  9]
  [12  3  8  6]]]
&quot;&quot;&quot;

n1 = n0.argsort()
print(n1)
&quot;&quot;&quot;
[[[1 0 2 3]
  [3 2 1 0]]

 [[0 2 3 1]
  [1 3 2 0]]]
&quot;&quot;&quot;

n2 = np.argsort(n0)
print(n2)
&quot;&quot;&quot;
[[[1 0 2 3]
  [3 2 1 0]]

 [[0 2 3 1]
  [1 3 2 0]]]
&quot;&quot;&quot;

n3 = np.argsort(n0, axis=0)
print(n3)
&quot;&quot;&quot;
[[[1 0 0 0]
  [1 1 1 0]]

 [[0 1 1 1]
  [0 0 0 1]]]
&quot;&quot;&quot;

n4 = np.argsort(n0, axis=1)
print(n4)
&quot;&quot;&quot;
[[[0 0 0 1]
  [1 1 1 0]]

 [[0 1 1 1]
  [1 0 0 0]]]
&quot;&quot;&quot;

n5 = np.argsort(n0, axis=2)
print(n5)
&quot;&quot;&quot;
[[[1 0 2 3]
  [3 2 1 0]]

 [[0 2 3 1]
  [1 3 2 0]]]
&quot;&quot;&quot;

n6 = np.argsort(n0, axis=None)
print(n6)
&quot;&quot;&quot;
[ 7  8 13  1  0  2 15  3 14  6 10 11  5  9 12  4]
&quot;&quot;&quot;

dtype = [('name', 'S10'), ('height', float), ('age', int)]
values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38), ('Galahad', 1.7, 38)]
n7 = np.array(values, dtype=dtype)
print(n7)
&quot;&quot;&quot;
[(b'Arthur', 1.8, 41) (b'Lancelot', 1.9, 38) (b'Galahad', 1.7, 38)]
&quot;&quot;&quot;

print(np.argsort(n7, order='height'))
&quot;&quot;&quot;
[2 0 1]
&quot;&quot;&quot;

print(np.argsort(n7, order=['age', 'height']))
&quot;&quot;&quot;
[2 1 0]
&quot;&quot;&quot;
</code></pre>
<h2 id="lexsort">lexsort函数</h2>
<p><code>lexsort(keys, axis=-1)</code>
若为多个一维数组，先根据最后一个数组进行排序，当出现相同时根据前一个数组进行排序，以此类推，返回排序后的索引
若为一个二维数组，先根据最后一行排序，当出现相同时根据上一行进行排序，以此类推，返回排序后的索引
若为多个二维数组，则每次根据axis从每个数组中取出一个一维数组后，彼此之间进行排序，返回排序后的索引组合</p>
<ol>
<li>
<p><strong>keys</strong>: 排序数组。若有多个数组，则每个数组必须是相同形状。默认最后一个数组作为初始排序数组。</p>
</li>
<li>
<p><strong>aixs</strong>: 若为多个二维数组，取出一维数组所沿的轴。默认为-1，即使用最后一个轴（1）</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.random.randint(1, 17, size=6)
print(n0)
&quot;&quot;&quot;
[ 3 15 13 16  9 13]
&quot;&quot;&quot;

n1 = np.random.randint(1, 17, size=6)
print(n1)
&quot;&quot;&quot;
[ 4 13  7 16 15  1]
&quot;&quot;&quot;

n2 = np.random.randint(1, 17, size=6)
print(n2)
&quot;&quot;&quot;
[15 12  5 13  7  7]
&quot;&quot;&quot;

n3 = np.lexsort((n0, n1, n2))
print(n3)
&quot;&quot;&quot;
[2 5 4 1 3 0]
&quot;&quot;&quot;

n4 = np.random.randint(1, 17, size=(4, 4))
print(n4)
&quot;&quot;&quot;
[[ 7  4 10 12]
 [15 12 12  8]
 [ 8  9 14  3]
 [ 5  2 16  1]]
&quot;&quot;&quot;

n5 = np.lexsort(n4)
print(n5)
&quot;&quot;&quot;
[3 1 0 2]
&quot;&quot;&quot;

n6 = np.random.randint(1, 17, size=(3, 4))
&quot;&quot;&quot;
[[16  2  9  5]
 [ 3  2  6  8]
 [ 1 12 11 14]]
&quot;&quot;&quot;

n7 = np.random.randint(1, 17, size=(3, 4))
&quot;&quot;&quot;
[[10  7 16 12]
 [ 7  1  5 11]
 [ 9  7  9 16]]
&quot;&quot;&quot;

n8 = np.lexsort((n6, n7), axis=1)
&quot;&quot;&quot;
[[1 0 3 2]
 [1 2 0 3]
 [1 0 2 3]]
&quot;&quot;&quot;

n9 = np.lexsort((n6, n7), axis=0)
&quot;&quot;&quot;
[[1 1 1 1]
 [2 0 2 0]
 [0 2 0 2]]
&quot;&quot;&quot;
</code></pre>
<h1 id="_21">数组一维化</h1>
<h2 id="flatten">flatten方法</h2>
<p>返回一个连续的一维（扁平）数组</p>
<p><code>ndarray.flatten(order="C")</code></p>
<pre><code class="language-Python">n0 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&quot;&quot;&quot;
[[1 2 3]
 [4 5 6]
 [7 8 9]]
&quot;&quot;&quot;

n1 = n0.flatten(order=&quot;C&quot;)
&quot;&quot;&quot;
[1 2 3 4 5 6 7 8 9]
&quot;&quot;&quot;

n2 = n0.flatten(order=&quot;F&quot;)
&quot;&quot;&quot;
[1 4 7 2 5 8 3 6 9]
&quot;&quot;&quot;
</code></pre>
<h2 id="ravel">ravel方法、函数</h2>
<p>返回一个连续的一维（扁平）数组</p>
<p><code>ndarray.ravel(order="C")</code></p>
<p><code>ravel(a, order='C')</code></p>
<ol>
<li>
<p><strong>a</strong>：同上</p>
</li>
<li>
<p><strong>order</strong>：同前</p>
</li>
</ol>
<pre><code class="language-Python">n0 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
&quot;&quot;&quot;
[[1 2 3]
 [4 5 6]
 [7 8 9]]
&quot;&quot;&quot;

n1 = np.ravel(n0, order='C')
n2 = n0.ravel(order='C')
&quot;&quot;&quot;
[1 2 3 4 5 6 7 8 9]
&quot;&quot;&quot;

n3 = np.ravel(n0, order='F')
n4 = n0.ravel(order='F')
&quot;&quot;&quot;
[1 4 7 2 5 8 3 6 9]
&quot;&quot;&quot;
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.f8cc74c7.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.f1b6f286.min.js"></script>
      
    
  </body>
</html>